<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Sea Breeze Visualiser</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <style>
    html, body { height: 100%; margin: 0; }
    #map { height: 100%; }

    #controls {
      position: absolute;
      bottom: 12px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 1000;
      background: rgba(255,255,255,0.95);
      padding: 8px 10px;
      border-radius: 10px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.2);
      font-family: system-ui, sans-serif;
      font-size: 14px;
      display: flex;
      gap: 8px;
      align-items: center;
    }

    .modeBtn {
      padding: 6px 12px;
      border-radius: 8px;
      border: 1px solid #bbb;
      background: #f3f3f3;
      cursor: pointer;
    }

    .modeBtn.selected {
      background: #111;
      color: #fff;
      border-color: #111;
    }

    .spinner {
      position: absolute;
      top: 50%;
      left: 50%;
      width: 48px;
      height: 48px;
      margin: -24px 0 0 -24px;
      border: 5px solid rgba(0,0,0,0.15);
      border-top-color: #111;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      z-index: 2000;
      pointer-events: none;
    }

    .spinner.hidden { display: none; }

    @keyframes spin { to { transform: rotate(360deg); } }
  </style>
</head>
<body>

<div id="map"></div>
<div id="spinner" class="spinner hidden"></div>

<div id="controls">
  <button id="qBtn" class="modeBtn selected">Spec. humidity</button>
  <button id="humBtn" class="modeBtn">Humidity</button>
  <button id="tempBtn" class="modeBtn">Temp</button>
</div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script>
  const map = L.map("map").setView([-33.645239, 150.556535], 11);

  L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
    attribution: "© OpenStreetMap contributors",
    maxZoom: 17
  }).addTo(map);

  const layer = L.layerGroup().addTo(map);

  const spinner = document.getElementById("spinner");
  function showSpinner() { spinner.classList.remove("hidden"); }
  function hideSpinner() { spinner.classList.add("hidden"); }

  const WINDOW_MS = 15 * 60 * 1000;
  const cache = new Map();

  let colorMode = "q"; // "q" | "humidity" | "temp"

  const qBtn = document.getElementById("qBtn");
  const humBtn = document.getElementById("humBtn");
  const tempBtn = document.getElementById("tempBtn");

  function setMode(mode) {
    colorMode = mode;
    qBtn.classList.toggle("selected", mode === "q");
    humBtn.classList.toggle("selected", mode === "humidity");
    tempBtn.classList.toggle("selected", mode === "temp");
    loadData();
  }

  qBtn.onclick = () => setMode("q");
  humBtn.onclick = () => setMode("humidity");
  tempBtn.onclick = () => setMode("temp");

  function fToC(f) { return (f - 32) * 5 / 9; }

  function inHgToHpa(inHg) {
    return (typeof inHg === "number") ? inHg * 33.8638866667 : null;
  }

  function specificHumidityGkg(tempC, rh, pressureHpa) {
    if (typeof tempC !== "number" || typeof rh !== "number" || typeof pressureHpa !== "number") return null;
    const es = 6.112 * Math.exp((17.67 * tempC) / (tempC + 243.5)); // hPa
    const e  = (rh / 100) * es;                                     // hPa
    const q  = (0.622 * e) / (pressureHpa - 0.378 * e);             // kg/kg
    return q * 1000; // g/kg
  }

  function getLatLon(f) {
    const c = f?.geometry?.coordinates;
    return (Array.isArray(c) && c.length >= 2) ? [c[1], c[0]] : null;
  }

  function ageToOpacity(validTimeMs) {
    if (typeof validTimeMs !== "number") return 0;
    const ageMs = Date.now() - validTimeMs;
    const maxAge = 30 * 60 * 1000;
    return Math.max(0, 1 - ageMs / maxAge);
  }

  // ---- OUTLIER REMOVAL (std dev) ----
  const OUTLIER_K = 2.5;

  function meanSd(vals) {
    const n = vals.length;
    if (n < 2) return { mean: null, sd: null };
    const mean = vals.reduce((a, b) => a + b, 0) / n;
    const varPop = vals.reduce((a, b) => a + (b - mean) * (b - mean), 0) / n;
    return { mean, sd: Math.sqrt(varPop) };
  }

  function filterOutliersByStd(features) {
    const temps = [];
    const hums = [];
    const qs = [];

    for (const f of features) {
      const p = f.properties || {};

      const t = (typeof p.tempf === "number") ? fToC(p.tempf) : null;
      const h = (typeof p.humidity === "number") ? p.humidity : null;
      const pHpa = inHgToHpa(p.baromin);
      const q = (typeof t === "number" && typeof h === "number" && typeof pHpa === "number")
        ? specificHumidityGkg(t, h, pHpa)
        : null;

      if (typeof t === "number") temps.push(t);
      if (typeof h === "number") hums.push(h);
      if (typeof q === "number") qs.push(q);
    }

    const tStats = meanSd(temps);
    const hStats = meanSd(hums);
    const qStats = meanSd(qs);

    const tLo = (tStats.mean != null && tStats.sd != null) ? tStats.mean - OUTLIER_K * tStats.sd : -Infinity;
    const tHi = (tStats.mean != null && tStats.sd != null) ? tStats.mean + OUTLIER_K * tStats.sd :  Infinity;

    const hLo = (hStats.mean != null && hStats.sd != null) ? hStats.mean - OUTLIER_K * hStats.sd : -Infinity;
    const hHi = (hStats.mean != null && hStats.sd != null) ? hStats.mean + OUTLIER_K * hStats.sd :  Infinity;

    const qLo = (qStats.mean != null && qStats.sd != null) ? qStats.mean - OUTLIER_K * qStats.sd : -Infinity;
    const qHi = (qStats.mean != null && qStats.sd != null) ? qStats.mean + OUTLIER_K * qStats.sd :  Infinity;

    return features.filter(f => {
      const p = f.properties || {};
      const t = (typeof p.tempf === "number") ? fToC(p.tempf) : null;
      const h = (typeof p.humidity === "number") ? p.humidity : null;
      const pHpa = inHgToHpa(p.baromin);
      const q = (typeof t === "number" && typeof h === "number" && typeof pHpa === "number")
        ? specificHumidityGkg(t, h, pHpa)
        : null;

      if (typeof t !== "number" || typeof h !== "number" || typeof q !== "number") return false;

      return (t >= tLo && t <= tHi) && (h >= hLo && h <= hHi) && (q >= qLo && q <= qHi);
    });
  }

  // ---- RANGES for max contrast ----
  let tempMin=null, tempMax=null, humMin=null, humMax=null, qMin=null, qMax=null;

  function computeRanges(features) {
    tempMin=humMin=qMin= Infinity;
    tempMax=humMax=qMax= -Infinity;

    for (const f of features) {
      const p = f.properties || {};
      const t = (typeof p.tempf==="number") ? fToC(p.tempf) : null;
      const h = (typeof p.humidity==="number") ? p.humidity : null;
      const pHpa = inHgToHpa(p.baromin);
      const q = (typeof t === "number" && typeof h === "number" && typeof pHpa === "number")
        ? specificHumidityGkg(t, h, pHpa)
        : null;

      if (typeof t === "number") { tempMin=Math.min(tempMin,t); tempMax=Math.max(tempMax,t); }
      if (typeof h === "number") { humMin=Math.min(humMin,h); humMax=Math.max(humMax,h); }
      if (typeof q === "number") { qMin=Math.min(qMin,q); qMax=Math.max(qMax,q); }
    }

    if (!Number.isFinite(tempMin) || !Number.isFinite(tempMax)) { tempMin=tempMax=null; }
    if (!Number.isFinite(humMin)  || !Number.isFinite(humMax))  { humMin=humMax=null; }
    if (!Number.isFinite(qMin)    || !Number.isFinite(qMax))    { qMin=qMax=null; }
  }

  // TEMP: low blue -> high red
  function tempToColor(t) {
    if (typeof t!=="number" || tempMin==null || tempMax==null || tempMax===tempMin) return "#888";
    const f=(t-tempMin)/(tempMax-tempMin);
    return `rgb(${Math.round(255*f)},0,${Math.round(255*(1-f))})`;
  }

  // HUMIDITY: low red -> high blue
  function humidityToColor(h) {
    if (typeof h!=="number" || humMin==null || humMax==null || humMax===humMin) return "#888";
    const f=(h-humMin)/(humMax-humMin);
    return `rgb(${Math.round(255*(1-f))},0,${Math.round(255*f)})`;
  }

  // SPEC HUM: low blue -> high red
  function qToColor(q) {
    if (typeof q!=="number" || qMin==null || qMax==null || qMax===qMin) return "#888";
    const f=(q-qMin)/(qMax-qMin);
    return `rgb(${Math.round(255*f)},0,${Math.round(255*(1-f))})`;
  }

  function floorToQuarterHour(ms) {
    const d = new Date(ms);
    d.setSeconds(0, 0);
    d.setMinutes(d.getMinutes() - (d.getMinutes() % 15));
    return d.getTime();
  }

  // ---- Multi-resolution tile fetching ----
  async function fetchFeaturesForGrid(startMs, endMs, { startX, startY, tilesX, tilesY, lod }) {
    const key = `${startMs}-${endMs}:${startX},${startY},${tilesX},${tilesY},lod${lod}`;
    if (cache.has(key)) return cache.get(key);

    let features = [];
    for (let x = startX; x <= startX + tilesX; x++) {
      for (let y = startY; y <= startY + tilesY; y++) {
        const url =
          `https://api.weather.com/v2/vector-api/products/614/features` +
          `?x=${x}&y=${y}&lod=${lod}&apiKey=e1f10a1e78da46f5b10a1e78da96f525` +
          `&tile-size=512&time=${startMs}-${endMs}`;

        const r = await fetch(url);
        const j = await r.json();
        features = features.concat(j.features);
      }
    }

    cache.set(key, features);
    return features;
  }

  async function fetchFeaturesMerged(startMs, endMs) {
    const centerReq = { startX: 1879, startY: 1226, tilesX: 1, tilesY: 1, lod: 12 };
    const wideReq   = { startX: 939,  startY: 613,  tilesX: 1, tilesY: 1, lod: 11 };

    const [center, wide] = await Promise.all([
      fetchFeaturesForGrid(startMs, endMs, centerReq),
      fetchFeaturesForGrid(startMs, endMs, wideReq),
    ]);

    return center.concat(wide);
  }

  function mostRecentPerStation(features, startMs, endMs) {
    const byId = new Map();

    for (const f of features) {
      const id = f?.id || f?.properties?.id;
      const vt = f?.properties?.validTime;
      if (!id || typeof vt !== "number") continue;
      if (vt < startMs || vt > endMs) continue;

      const prev = byId.get(id);
      if (!prev || vt > prev.properties.validTime) byId.set(id, f);
    }

    return [...byId.values()];
  }

  async function loadData() {
    showSpinner();
    try {
      const start = floorToQuarterHour(Date.now());
      const end = start + WINDOW_MS;
      const prevStart = start - WINDOW_MS;

      const [bucketPrev, bucketNow] = await Promise.all([
        fetchFeaturesMerged(prevStart, start),
        fetchFeaturesMerged(start, end)
      ]);

      const latest = mostRecentPerStation(bucketPrev.concat(bucketNow), prevStart, end);

      // apply outlier filtering (temp + RH + spec humidity)
      const filtered = filterOutliersByStd(latest);

      // compute contrast ranges from filtered set
      computeRanges(filtered);

      layer.clearLayers();

      for (const f of filtered) {
        const ll = getLatLon(f);
        if (!ll) continue;

        const p = f.properties || {};
        const t = (typeof p.tempf === "number") ? fToC(p.tempf) : null;
        const h = (typeof p.humidity === "number") ? p.humidity : null;
        const pHpa = inHgToHpa(p.baromin);
        const q = (typeof t === "number" && typeof h === "number" && typeof pHpa === "number")
          ? specificHumidityGkg(t, h, pHpa)
          : null;

        const fillColor =
          (colorMode === "q") ? qToColor(q) :
          (colorMode === "humidity") ? humidityToColor(h) :
          tempToColor(t);

        const op = ageToOpacity(p.validTime);
        if (op <= 0) continue;

        L.circleMarker(ll, {
          radius: 9,
          fillColor,
          color: "#000",
          weight: 0,
          fillOpacity: op
        })
        .bindPopup(
          `<strong>${p.neighborhood ?? f.id}</strong><br>
           Temp: ${t !== null ? t.toFixed(1) : "—"} °C<br>
           Humidity: ${h !== null ? h : "—"} %<br>
           Spec. humidity: ${q !== null ? q.toFixed(1) : "—"} g/kg<br>
           Updated: ${
            p.validTime
              ? new Date(p.validTime).toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" })
              : "—"
          }`
        )
        .addTo(layer);
      }
    } finally {
      hideSpinner();
    }
  }

  loadData();
</script>

</body>
</html>
