<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Sea Breeze Tracker</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <style>
    html, body { height: 100%; margin: 0; }
    #map { height: 100%; }

    #controls {
      position: absolute;
      bottom: 12px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 1000;
      background: rgba(255,255,255,0.95);
      padding: 8px 10px;
      border-radius: 10px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.2);
      font-family: system-ui, sans-serif;
      font-size: 14px;
      display: flex;
      gap: 8px;
      align-items: center;
    }

    .modeBtn {
      padding: 6px 12px;
      border-radius: 8px;
      border: 1px solid #bbb;
      background: #f3f3f3;
      cursor: pointer;
    }

    .modeBtn.selected {
      background: #111;
      color: #fff;
      border-color: #111;
    }

    .spinner {
      position: absolute;
      top: 50%;
      left: 50%;
      width: 48px;
      height: 48px;
      margin: -24px 0 0 -24px;
      border: 5px solid rgba(0,0,0,0.15);
      border-top-color: #111;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      z-index: 2000;
      pointer-events: none;
    }

    .spinner.hidden { display: none; }
    @keyframes spin { to { transform: rotate(360deg); } }

    .modeBtn{
  height: 34px;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  line-height: 1;
}

.modeBtnHelp{
  width: 34px;       /* makes ? and ✕ square */
  padding: 0;
  font-weight: 700;
}

/* Modal */
.modal.hidden { display: none; }

.modal{
  position: fixed;
  inset: 0;
  z-index: 3000;
  display: grid;
  place-items: center;
}

.modalBackdrop{
  position: absolute;
  inset: 0;
  background: rgba(0,0,0,0.45);
}

.modalCard{
  position: relative;
  width: min(640px, calc(100vw - 24px));
  max-height: min(70vh, 560px);
  overflow: auto;
  background: #fff;
  border-radius: 12px;
  box-shadow: 0 10px 40px rgba(0,0,0,0.35);
  padding: 14px 14px 10px;
  font-family: system-ui, sans-serif;
}

.modalHeader{
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 10px;
  margin-bottom: 8px;
}

.modalHeader h2{
  margin: 0;
  font-size: 18px;
}

.modalBody p{
  margin: 0 0 10px 0;
  line-height: 1.35;
}

  </style>
</head>
<body>

<div id="map"></div>
<div id="spinner" class="spinner hidden"></div>

<div id="controls">
  <button id="qBtn" class="modeBtn selected">Specific humidity</button>
  <button id="humBtn" class="modeBtn">Relative humidity</button>
  <button id="tempBtn" class="modeBtn">Temperature</button>
  <button id="helpBtn" class="modeBtn modeBtnHelp" aria-label="Help">?</button>
</div>
<div id="helpModal" class="modal hidden" role="dialog" aria-modal="true" aria-labelledby="helpTitle">
  <div class="modalBackdrop" data-close="1"></div>
  <div class="modalCard">
    <div class="modalHeader">
      <h2 id="helpTitle">What is all this?</h2>
      <button id="helpClose" class="modeBtn modeBtnHelp" aria-label="Close">✕</button>
    </div>
    <div class="modalBody" id="helpBody">
      <p>
        This map shows live weather-station observations to help visualise the inland push of the sea breeze for the benefit of glider pilots.
        Each circle is a station. Colour indicates the magnitude of the variable you selected (specific humidity, relative humidity, or temperature).
      </p>
      <p>
        Specific humidity (g/kg) is a measure of how much water vapour is in the air. It’s often a good tracer of marine air
        because it increases when moist coastal air arrives and is not affected by temperature or pressure changes like relative
        humidity is.
      </p>
      <p>
        The data comes from the most recent station reading within the last ~30 minutes. Older readings are drawn more faintly:
        fully opaque means “very recent”, and fading to transparent means “about 30 minutes old”.
      </p>
      <p>
        Colours are scaled around the median value so you can see contrast and boundaries more clearly. Obvious outliers are removed
        automatically.
      </p>
      <p>
        You can click on a station to see its exact values.
      </p>
    </div>
  </div>
</div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script>
  // ---- MAP ----
  const map = L.map("map").setView([-33.645239, 150.556535], 9);

  const osm = L.tileLayer(
  "https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png",
  { attribution: "© OpenStreetMap contributors", maxZoom: 17 }
).addTo(map);

const hillshade = L.tileLayer(
  "https://server.arcgisonline.com/ArcGIS/rest/services/Elevation/World_Hillshade/MapServer/tile/{z}/{y}/{x}",
  { attribution: "Tiles © Esri", maxZoom: 17, opacity: 0.2 }
).addTo(map);


  const layer = L.layerGroup().addTo(map);

  // ---- UI ----
  const spinner = document.getElementById("spinner");
  function showSpinner() { spinner.classList.remove("hidden"); }
  function hideSpinner() { spinner.classList.add("hidden"); }

  const qBtn = document.getElementById("qBtn");
  const humBtn = document.getElementById("humBtn");
  const tempBtn = document.getElementById("tempBtn");

  let colorMode = "q"; // "q" | "humidity" | "temp"

  function setMode(mode) {
    colorMode = mode;
    qBtn.classList.toggle("selected", mode === "q");
    humBtn.classList.toggle("selected", mode === "humidity");
    tempBtn.classList.toggle("selected", mode === "temp");
    loadData();
  }

  qBtn.onclick = () => setMode("q");
  humBtn.onclick = () => setMode("humidity");
  tempBtn.onclick = () => setMode("temp");

  // ---- CONSTANTS ----
  const WINDOW_MS = 15 * 60 * 1000;
  const cache = new Map();

  // median-centered ranges
  const TEMP_RANGE_C = 10;     // total span
  const HUM_RANGE_PCT = 20;    // total span
  const Q_RANGE_GKG = 5;       // total span

  // outlier filtering
  const OUTLIER_K = 2.5;

  // ---- MATH / HELPERS ----
  function fToC(f) { return (f - 32) * 5 / 9; }

  function inHgToHpa(inHg) {
    return (typeof inHg === "number") ? inHg * 33.8638866667 : null;
  }

  function specificHumidityGkg(tempC, rh, pressureHpa) {
    if (typeof tempC !== "number" || typeof rh !== "number" || typeof pressureHpa !== "number") return null;
    const es = 6.112 * Math.exp((17.67 * tempC) / (tempC + 243.5)); // hPa
    const e  = (rh / 100) * es;                                     // hPa
    const q  = (0.622 * e) / (pressureHpa - 0.378 * e);             // kg/kg
    return q * 1000; // g/kg
  }

  function getLatLon(f) {
    const c = f?.geometry?.coordinates;
    return (Array.isArray(c) && c.length >= 2) ? [c[1], c[0]] : null;
  }

  function ageToOpacity(validTimeMs) {
    if (typeof validTimeMs !== "number") return 0;
    const ageMs = Date.now() - validTimeMs;
    const maxAge = 30 * 60 * 1000;
    const f = 1 - (ageMs / maxAge);
    return Math.max(0, Math.min(1, f));
  }

  function floorToQuarterHour(ms) {
    const d = new Date(ms);
    d.setSeconds(0, 0);
    d.setMinutes(d.getMinutes() - (d.getMinutes() % 15));
    return d.getTime();
  }

  function meanSd(vals) {
    const a = vals.filter(v => typeof v === "number" && Number.isFinite(v));
    const n = a.length;
    if (n < 2) return { mean: null, sd: null };
    const mean = a.reduce((s, v) => s + v, 0) / n;
    const varPop = a.reduce((s, v) => s + (v - mean) * (v - mean), 0) / n;
    return { mean, sd: Math.sqrt(varPop) };
  }

  function median(vals) {
    const a = vals.filter(v => typeof v === "number" && Number.isFinite(v)).sort((x, y) => x - y);
    const n = a.length;
    if (!n) return null;
    const mid = Math.floor(n / 2);
    return (n % 2) ? a[mid] : (a[mid - 1] + a[mid]) / 2;
  }

  function clamp01(x) { return Math.max(0, Math.min(1, x)); }

// low = blue, high = red (keep for temperature)
function blueToRed(v, vMin, vMax) {
  if (typeof v !== "number" || vMin == null || vMax == null || vMax === vMin) return "#888";
  const f = Math.max(0, Math.min(1, (v - vMin) / (vMax - vMin)));
  return `rgb(${Math.round(255*f)},0,${Math.round(255*(1-f))})`;
}

// low = red, high = blue (use for humidity + specific humidity)
function redToBlue(v, vMin, vMax) {
  if (typeof v !== "number" || vMin == null || vMax == null || vMax === vMin) return "#888";
  const f = Math.max(0, Math.min(1, (v - vMin) / (vMax - vMin)));
  return `rgb(${Math.round(255*(1-f))},0,${Math.round(255*f)})`;
}


  // ---- OUTLIER FILTERING (temp + RH + q) ----
  function filterOutliersByStd(features) {
    const temps = [];
    const hums = [];
    const qs = [];

    for (const f of features) {
      const p = f.properties || {};
      const t = (typeof p.tempf === "number") ? fToC(p.tempf) : null;
      const h = (typeof p.humidity === "number") ? p.humidity : null;
      const pHpa = inHgToHpa(p.baromin);
      const q = (typeof t === "number" && typeof h === "number" && typeof pHpa === "number")
        ? specificHumidityGkg(t, h, pHpa)
        : null;

      if (typeof t === "number") temps.push(t);
      if (typeof h === "number") hums.push(h);
      if (typeof q === "number") qs.push(q);
    }

    const tStats = meanSd(temps);
    const hStats = meanSd(hums);
    const qStats = meanSd(qs);

    const tLo = (tStats.mean != null && tStats.sd != null) ? tStats.mean - OUTLIER_K * tStats.sd : -Infinity;
    const tHi = (tStats.mean != null && tStats.sd != null) ? tStats.mean + OUTLIER_K * tStats.sd :  Infinity;

    const hLo = (hStats.mean != null && hStats.sd != null) ? hStats.mean - OUTLIER_K * hStats.sd : -Infinity;
    const hHi = (hStats.mean != null && hStats.sd != null) ? hStats.mean + OUTLIER_K * hStats.sd :  Infinity;

    const qLo = (qStats.mean != null && qStats.sd != null) ? qStats.mean - OUTLIER_K * qStats.sd : -Infinity;
    const qHi = (qStats.mean != null && qStats.sd != null) ? qStats.mean + OUTLIER_K * qStats.sd :  Infinity;

    return features.filter(f => {
      const p = f.properties || {};
      const t = (typeof p.tempf === "number") ? fToC(p.tempf) : null;
      const h = (typeof p.humidity === "number") ? p.humidity : null;
      const pHpa = inHgToHpa(p.baromin);
      const q = (typeof t === "number" && typeof h === "number" && typeof pHpa === "number")
        ? specificHumidityGkg(t, h, pHpa)
        : null;

      if (typeof t !== "number" || typeof h !== "number" || typeof q !== "number") return false;

      return (t >= tLo && t <= tHi) && (h >= hLo && h <= hHi) && (q >= qLo && q <= qHi);
    });
  }

  // ---- MEDIAN-CENTERED RANGES ----
  let tempMin=null, tempMax=null, humMin=null, humMax=null, qMin=null, qMax=null;

  function computeRanges(features) {
    const temps = [];
    const hums = [];
    const qs = [];

    for (const f of features) {
      const p = f.properties || {};
      const t = (typeof p.tempf === "number") ? fToC(p.tempf) : null;
      const h = (typeof p.humidity === "number") ? p.humidity : null;
      const pHpa = inHgToHpa(p.baromin);
      const q = (typeof t === "number" && typeof h === "number" && typeof pHpa === "number")
        ? specificHumidityGkg(t, h, pHpa)
        : null;

      if (typeof t === "number") temps.push(t);
      if (typeof h === "number") hums.push(h);
      if (typeof q === "number") qs.push(q);
    }

    const tMed = median(temps);
    const hMed = median(hums);
    const qMed = median(qs);

    const tHalf = TEMP_RANGE_C / 2;
    const hHalf = HUM_RANGE_PCT / 2;
    const qHalf = Q_RANGE_GKG / 2;

    tempMin = (tMed == null) ? null : tMed - tHalf;
    tempMax = (tMed == null) ? null : tMed + tHalf;

    humMin  = (hMed == null) ? null : hMed - hHalf;
    humMax  = (hMed == null) ? null : hMed + hHalf;

    qMin    = (qMed == null) ? null : qMed - qHalf;
    qMax    = (qMed == null) ? null : qMed + qHalf;
  }

  function tempToColor(t)      { return blueToRed(t, tempMin, tempMax); }
function humidityToColor(h)  { return redToBlue(h, humMin, humMax); }
function qToColor(q)         { return redToBlue(q, qMin, qMax); }


  // ---- Multi-resolution tile fetching ----
  async function fetchFeaturesForGrid(startMs, endMs, { startX, startY, tilesX, tilesY, lod }) {
    const key = `${startMs}-${endMs}:${startX},${startY},${tilesX},${tilesY},lod${lod}`;
    if (cache.has(key)) return cache.get(key);

    let features = [];
    for (let x = startX; x <= startX + tilesX; x++) {
      for (let y = startY; y <= startY + tilesY; y++) {
        const url =
          `https://api.weather.com/v2/vector-api/products/614/features` +
          `?x=${x}&y=${y}&lod=${lod}&apiKey=e1f10a1e78da46f5b10a1e78da96f525` +
          `&tile-size=512&time=${startMs}-${endMs}`;

        const r = await fetch(url);
        const j = await r.json();
        features = features.concat(j.features);
      }
    }

    cache.set(key, features);
    return features;
  }

  const TILE_REQUESTS = [
  { startX: 1879, startY: 1226, tilesX: 1, tilesY: 1, lod: 12 }, // blue mountains hi-res
  { startX: 939,  startY: 613,  tilesX: 1, tilesY: 1, lod: 11 }, 
  //{ startX: 469,  startY: 306,  tilesX: 1, tilesY: 1, lod: 10 },
  { startX: 234,  startY: 152,  tilesX: 2, tilesY: 2, lod: 9 },
  { startX: 28,  startY: 18,  tilesX: 1, tilesY: 1, lod: 6 },
];


  async function fetchFeaturesMerged(startMs, endMs) {
    const tasks = TILE_REQUESTS.map(cfg =>
      fetchFeaturesForGrid(startMs, endMs, cfg)
    );

    const buckets = await Promise.all(tasks);

    return buckets.flat();
  }


  function mostRecentPerStation(features, startMs, endMs) {
    const byId = new Map();

    for (const f of features) {
      const id = f?.id || f?.properties?.id;
      const vt = f?.properties?.validTime;
      if (!id || typeof vt !== "number") continue;
      if (vt < startMs || vt > endMs) continue;

      const prev = byId.get(id);
      if (!prev || vt > prev.properties.validTime) byId.set(id, f);
    }

    return [...byId.values()];
  }

  async function loadData() {
    showSpinner();
    try {
      const start = floorToQuarterHour(Date.now());
      const end = start + WINDOW_MS;
      const prevStart = start - WINDOW_MS;

      const [bucketPrev, bucketNow] = await Promise.all([
        fetchFeaturesMerged(prevStart, start),
        fetchFeaturesMerged(start, end)
      ]);

      const latest = mostRecentPerStation(bucketPrev.concat(bucketNow), prevStart, end);

      // outlier filtering first
      const filtered = filterOutliersByStd(latest);

      // median-centered ranges next
      computeRanges(filtered);

      layer.clearLayers();

      for (const f of filtered) {
        const ll = getLatLon(f);
        if (!ll) continue;

        const p = f.properties || {};
        const t = (typeof p.tempf === "number") ? fToC(p.tempf) : null;
        const h = (typeof p.humidity === "number") ? p.humidity : null;
        const pHpa = inHgToHpa(p.baromin);
        const q = (typeof t === "number" && typeof h === "number" && typeof pHpa === "number")
          ? specificHumidityGkg(t, h, pHpa)
          : null;

        const fillColor =
          (colorMode === "q") ? qToColor(q) :
          (colorMode === "humidity") ? humidityToColor(h) :
          tempToColor(t);

        const op = ageToOpacity(p.validTime);
        if (op <= 0) continue;

        L.circleMarker(ll, {
          radius: 9,
          fillColor,
          color: "#000",
          weight: 0,
          fillOpacity: op
        })
        .bindPopup(
          `<strong>${p.neighborhood ?? f.id}</strong><br>
          Spec. humidity: ${q !== null ? q.toFixed(1) : "—"} g/kg<br>
           Rel. humidity: ${h !== null ? h : "—"} %<br>
           Temp: ${t !== null ? t.toFixed(1) : "—"} °C<br>
           Updated: ${
            p.validTime
              ? new Date(p.validTime).toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" })
              : "—"
          }`
        )
        .addTo(layer);
      }
    } finally {
      hideSpinner();
    }
  }

  loadData();

  // ---- HELP MODAL ----
const helpBtn = document.getElementById("helpBtn");
const helpModal = document.getElementById("helpModal");
const helpClose = document.getElementById("helpClose");

console.log("helpBtn?", !!helpBtn, "helpModal?", !!helpModal, "helpClose?", !!helpClose);

function openHelp() {
  console.log("openHelp()");
  helpModal.classList.remove("hidden");
}

function closeHelp() {
  console.log("closeHelp()");
  helpModal.classList.add("hidden");
}

helpBtn.addEventListener("click", openHelp);
helpClose.addEventListener("click", closeHelp);

// click on backdrop closes (you used data-close="1")
helpModal.addEventListener("click", (e) => {
  if (e.target?.dataset?.close) closeHelp();
});

</script>
</body>
</html>
